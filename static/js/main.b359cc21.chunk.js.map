{"version":3,"sources":["Translation.js","App.js","serviceWorker.js","index.js"],"names":["TranslationHelper","IndexHandlers","v","toFixed","Math","floor","stringformat","fmt","args","Array","prototype","slice","call","arguments","replace","match","number","GetTranslationLinesForMod","translationJson","mod","values","consumedIdxs","Set","translationLines","statIdx","has","statObj","statId","translationIdx","add","translation","translationStatIdx","findIndex","x","translationLine","numStatsInTranslation","length","fill","addlStatIdx","addlStat","addlStatId","addlStatTranslationIdx","push","GetTranslationRuleForLine","line","translationRule","conditionsFailed","condition","value","ApplyIndexHandlers","indexHandlers","handler","this","GetStringForTranslationRule","rule","replacementStrings","replacementMin","replacementMax","replacementValue","replacementCombined","GetStringsForTranslationLines","strings","lineIdx","TranslateMod","randRange","rng","minInclusive","maxInclusive","quick","TipLine","props","className","PropertyLine","ItemNameLine","topLine","key","bottomLine","CraftedItem","getItemTypeName","base_items","itemState","baseItemId","getTipLine","modInstance","context","mods","id","toUpperCase","tier","getStatLines","stat_translations","map","i","getImplicitLine","getImplicitLines","implicits","getAffixLine","getAffixLines","affixes","generatedName","React","Component","CanBaseItemHaveRarity","rarity","GetSpawnWeightForMod","modId","tags","spawnWeight","includes","GetPrefixCount","existingAffixCount","GetSuffixCount","GetAffixCount","GetPrefixLimitForRarity","baseItem","GetSuffixLimitForRarity","GetAffixLimitForRarity","GetAffixLimit","CanModBeAddedToItem","level","GetPrefixLimit","GetSuffixLimit","modGroup","affix","GetInfluenceTags","influence","baseItemClass","item_classes","influenceTagId","influenceTag","GetAddedTags","GetItemTags","concat","influences","implicit","GetBaseItemTags","RollModValues","statRolls","stat","CreateRolledMod","RollRareAffixCount","maxAffixCount","randInt","AddRandomMod","newItemState","modPool","randRoll","totalWeight","weightAccum","modEndWeight","weight","PickModFromWeightedModPool","modIds","modWeight","CreateWeightedModPool","validMods","GetValidModsForItem","CanScourItem","corrupted","ScourItem","CanTransmutationItem","TransmutationItem","numMods","CanAlterationItem","AlterationItem","CanAugmentationItem","AugmentationItem","result","CanRegalItem","RegalItem","CanAlchemyItem","AlchemyItem","CanChaosItem","ChaosItem","CanExaltedItem","ExaltedItem","CraftingButton","onClick","disabled","enabled","label","TheoryCrafter","testMap","actionMap","seedrandom","normalItemState","quality","corruptions","implicitId","CreateItem","transmuteResult","state","actionName","setState","performAction","canPerformAction","RenderCraftingButton","App","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b359cc21.chunk.js","sourcesContent":["export default class TranslationHelper {\r\n    static IndexHandlers = {\r\n        \"30%_of_value\": v => { return v * 0.3 },\r\n        \"60%_of_value\": v => { return v * 0.6 },\r\n        \"deciseconds_to_seconds\": v => { return v / 10 },\r\n        \"divide_by_one_hundred\": v => { return v / 100 },\r\n        \"divide_by_one_hundred_and_negate\": v => { return -v / 100 },\r\n        \"divide_by_one_hundred_2dp\": v => { return (v / 100).toFixed(2) },\r\n        \"milliseconds_to_seconds\": v => { return v / 1000 },\r\n        \"milliseconds_to_seconds_0dp\": v => { return (v / 1000).toFixed(0) },\r\n        \"milliseconds_to_seconds_1dp\": v => { return (v / 1000).toFixed(1) },\r\n        \"milliseconds_to_seconds_2dp\": v => { return (v / 1000).toFixed(2) },\r\n        \"milliseconds_to_seconds_2dp_if_required\": v => { return (v / 1000).toFixed(2) },\r\n        \"multiplicative_damage_modifier\": v => { return v + 100 },\r\n        \"multiplicative_permyriad_damage_modifier\": v => { return v / 100 + 100 },\r\n        \"negate\": v => { return -v },\r\n        \"old_leech_percent\": v => { return v / 5 },\r\n        \"old_leech_permyriad\": v => { return v / 500 },\r\n        \"per_minute_to_per_second\": v => { return (v / 60).toFixed(1) },\r\n        \"per_minute_to_per_second_0dp\": v => { return (v / 60).toFixed(0) },\r\n        \"per_minute_to_per_second_1dp\": v => { return (v / 60).toFixed(1) },\r\n        \"per_minute_to_per_second_2dp\": v => { return (v / 60).toFixed(2) },\r\n        \"per_minute_to_per_second_2dp_if_required\": v => { return (v / 60).toFixed(2) },\r\n        \"divide_by_two_0dp\": v => { return Math.floor(v / 2) },\r\n        \"divide_by_six\": v => { return v / 6 },\r\n        \"divide_by_ten_0dp\": v => { return Math.floor(v / 10) },\r\n        \"divide_by_twelve\": v => { return v / 12 },\r\n        \"divide_by_fifteen_0dp\": v => { return Math.floor(v / 15) },\r\n        \"divide_by_twenty_then_double_0dp\": v => { return Math.floor(v / 20) * 2 },\r\n        \"times_twenty\": v => { return v * 20 }\r\n    };\r\n\r\n    static stringformat = function(fmt) {\r\n        const args = Array.prototype.slice.call(arguments, 1);\r\n        return fmt.replace(/{(\\d+)}/g, (match, number) => {\r\n            return args[0][number];\r\n        });\r\n    }\r\n\r\n    static GetTranslationLinesForMod = function(translationJson, mod, values = null) {\r\n        let consumedIdxs = new Set();\r\n        let translationLines = [];\r\n        for (let statIdx in mod[\"stats\"]) {\r\n            if (consumedIdxs.has(statIdx)) {\r\n                continue;\r\n            }\r\n            const statObj = mod[\"stats\"][statIdx];\r\n            const statId = statObj[\"id\"];\r\n            consumedIdxs.add(statIdx);\r\n\r\n            for (const translationIdx in translationJson) {\r\n                const translation = translationJson[translationIdx];\r\n                const translationStatIdx = translation[\"ids\"].findIndex((x => x === statId));\r\n                if (translationStatIdx >= 0) {\r\n                    let translationLine = {};\r\n                    translationLine[\"tidx\"] = translationIdx;\r\n                    const numStatsInTranslation = translation[\"ids\"].length;\r\n                    translationLine[\"mins\"] = Array(numStatsInTranslation).fill(0);\r\n                    translationLine[\"maxs\"] = Array(numStatsInTranslation).fill(0);\r\n                    if (values)\r\n                        translationLine[\"values\"] = Array(numStatsInTranslation).fill(0);\r\n\r\n                    translationLine[\"mins\"][translationStatIdx] = statObj[\"min\"];\r\n                    translationLine[\"maxs\"][translationStatIdx] = statObj[\"max\"];\r\n                    if (values)                    \r\n                        translationLine[\"values\"][translationStatIdx] = values[statIdx];\r\n\r\n                    for (let addlStatIdx in mod[\"stats\"]) {\r\n                        const addlStat = mod[\"stats\"][addlStatIdx];\r\n                        const addlStatId = addlStat[\"id\"];\r\n                        if (consumedIdxs.has(addlStatIdx)) {\r\n                            continue;\r\n                        }\r\n                        const addlStatTranslationIdx = translation[\"ids\"].findIndex((x => x === addlStatId));\r\n                        if (addlStatTranslationIdx > 0) {\r\n                            translationLine[\"mins\"][addlStatTranslationIdx] = addlStat[\"min\"];\r\n                            translationLine[\"maxs\"][addlStatTranslationIdx] = addlStat[\"max\"];\r\n                            if (values)                            \r\n                                translationLine[\"values\"][addlStatTranslationIdx] = values[addlStatIdx];\r\n\r\n                            consumedIdxs.add(addlStatIdx);\r\n                        }\r\n                    }\r\n                    translationLines.push(translationLine);\r\n                }\r\n            }\r\n        }\r\n        return translationLines;\r\n    }\r\n\r\n    static GetTranslationRuleForLine = function(translationJson, line) {\r\n        const translation = translationJson[line[\"tidx\"]][\"English\"];\r\n        for (const translationRule of translation) {\r\n            let conditionsFailed = false;\r\n            for (const statIdx in line[\"mins\"]) {\r\n                let condition = translationRule[\"condition\"][statIdx];\r\n                const value = line[\"mins\"][statIdx];\r\n                if (\"min\" in condition) {\r\n                    if (value < condition[\"min\"]) {\r\n                        conditionsFailed = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (\"max\" in condition) {\r\n                    if (value > condition[\"max\"]) {\r\n                        conditionsFailed = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!conditionsFailed) {\r\n                return translationRule;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static ApplyIndexHandlers = function(indexHandlers, value) {\r\n        for (const handler of indexHandlers) {\r\n            value = this.IndexHandlers[handler](value)\r\n        }\r\n        return value;\r\n    }\r\n\r\n    static GetStringForTranslationRule = function(translationJson, rule, line) {\r\n        const translation = translationJson[line[\"tidx\"]];\r\n        let replacementStrings = Array(translation[\"ids\"].length);\r\n        for (const statIdx in translation[\"ids\"]) {\r\n            const replacementMin = this.ApplyIndexHandlers(rule[\"index_handlers\"][statIdx], line[\"mins\"][statIdx]);\r\n            const replacementMax = this.ApplyIndexHandlers(rule[\"index_handlers\"][statIdx], line[\"maxs\"][statIdx]);\r\n            let replacementValue = null;\r\n            if (\"values\" in line) {\r\n                replacementValue = this.ApplyIndexHandlers(rule[\"index_handlers\"][statIdx], line[\"values\"][statIdx]);\r\n            }\r\n\r\n            let replacementCombined = \"\";\r\n            if (replacementMin === replacementMax) {\r\n                replacementCombined = replacementMin;\r\n            }\r\n            else {\r\n                replacementCombined = \"(\" + replacementMin + \"-\" + replacementMax + \")\";\r\n                if (replacementValue) {\r\n                    replacementCombined = replacementValue + replacementCombined;\r\n                }\r\n            }\r\n            replacementStrings[statIdx] = rule[\"format\"][statIdx].replace(\"#\", replacementCombined);\r\n        }\r\n        return this.stringformat(rule[\"string\"], replacementStrings);\r\n    }\r\n\r\n    static GetStringsForTranslationLines = function(translationJson, translationLines) {\r\n        let strings = Array(translationLines.length).fill(\"\");\r\n        for (const lineIdx in translationLines) {\r\n            const translationRule = this.GetTranslationRuleForLine(translationJson, translationLines[lineIdx]);\r\n            if (translationRule) {\r\n                strings[lineIdx] = this.GetStringForTranslationRule(translationJson, translationRule, translationLines[lineIdx]);\r\n            }\r\n        }\r\n        return strings;\r\n    }\r\n\r\n    static TranslateMod = function(translationJson, mod, values = null) {\r\n        const translationLines = this.GetTranslationLinesForMod(translationJson, mod, values);\r\n        return this.GetStringsForTranslationLines(translationJson, translationLines);\r\n    }\r\n}","import React from 'react';\nimport './App.css';\nimport TranslationHelper from './Translation.js';\nimport seedrandom from 'seedrandom';\n\nimport base_items from './data/base_items.json';\nimport item_classes from './data/item_classes.json';\nimport mods from './data/mods.json';\nimport stat_translations from './data/stat_translations.json';\n\nfunction randRange(rng, minInclusive, maxInclusive) {\n  return Math.floor(rng.quick() * (maxInclusive - minInclusive + 1)) + minInclusive;\n}\n\nfunction TipLine (props) {\n  return <div className=\"tipLine\">{props.line}</div>\n}\n\nfunction PropertyLine (props) {\n  return <div className=\"modLine\">{props.line}</div>\n}\n\nfunction ItemNameLine (props) {\n  return [props.topLine && <div className=\"itemName\" key=\"itemName_top\">{props.topLine}</div>, props.bottomLine && <div className=\"itemName\" key=\"itemName_bottom\">{props.bottomLine}</div>];\n}\n\nclass CraftedItem extends React.Component {\n  getItemTypeName = function() {\n    return base_items[this.props.itemState.baseItemId][\"name\"];\n  }\n\n  getTipLine = function(modInstance, context) {\n    const mod = mods[modInstance.id];\n    let line = \"\";\n    if (context === \"prefix\" || context === \"suffix\") {\n      line = context[0].toUpperCase() + context.slice(1) + \" Modifier \\\"\" + mod[\"name\"] + \"\\\"\" + (modInstance.tier > 0 ? (\" (Tier: \" + modInstance.tier + \")\") : \"\");\n    }\n    else if (context === \"unique\" || context === \"implicit\") {\n      line = context[0].toUpperCase() + context.slice(1) + \" Modifier\";\n    }\n    return <TipLine line={line} key={modInstance.id + \"_tip\"}/>;\n  }\n\n  getStatLines = function(modInstance) {\n    const mod = mods[modInstance.id];\n    const values = modInstance.values;\n    const translationStrings = TranslationHelper.TranslateMod(stat_translations, mod, values);    \n    return translationStrings.map((x, i) => <PropertyLine line={x} key={modInstance.id + \"_mod_\" + i}/>);\n  }\n\n  getImplicitLine = function(modInstance) {\n    return [this.getTipLine(modInstance, \"implicit\"), this.getStatLines(modInstance)];\n  }\n\n  getImplicitLines = function() {\n    return this.props.itemState.implicits.map(x => this.getImplicitLine(x));\n  }\n\n  getAffixLine = function(modInstance) {\n    return [this.getTipLine(modInstance, mods[modInstance.id][\"generation_type\"]), this.getStatLines(modInstance)];\n  }\n\n  getAffixLines = function() {\n    return this.props.itemState.affixes.map(x => this.getAffixLine(x));\n  }\n\n  render() {\n    return [\n      <ItemNameLine topLine={this.props.itemState.generatedName} bottomLine={this.getItemTypeName()} key=\"nameLine\"/>, \n      <div className=\"separator\" key=\"sep1\">---</div>, \n      this.getImplicitLines(),\n      <div className=\"separator\" key=\"sep2\">---</div>,\n      this.getAffixLines()]\n  }\n}\n\nfunction CanBaseItemHaveRarity(baseItemId, rarity) {\n  const baseItem = base_items[baseItemId];\n  if (baseItem[\"domain\"] === \"flask\") {\n    return rarity !== \"rare\";\n  }\n  return true;\n}\n\nfunction GetSpawnWeightForMod(modId, tags) {\n  const mod = mods[modId];\n  for (const spawnWeight of mod[\"spawn_weights\"]) {\n    if (tags.includes(spawnWeight[\"tag\"])) {\n      return spawnWeight[\"weight\"];\n    }\n  }\n  return 0;\n}\n\nfunction GetPrefixCount(itemState) {\n  let existingAffixCount = 0;\n  for (let i = 0; i < itemState.affixes.length; ++i) {\n    const affix = mods[itemState.affixes[i].id];\n    if (affix[\"generation_type\"] === \"prefix\") {\n      existingAffixCount++;\n    }\n  }\n  return existingAffixCount;\n}\n\nfunction GetSuffixCount(itemState) {\n  let existingAffixCount = 0;\n  for (let i = 0; i < itemState.affixes.length; ++i) {\n    const affix = mods[itemState.affixes[i].id];\n    if (affix[\"generation_type\"] === \"suffix\") {\n      existingAffixCount++;\n    }\n  }\n  return existingAffixCount;\n}\n\nfunction GetAffixCount(itemState) {\n  return GetPrefixCount(itemState) + GetSuffixCount(itemState);\n}\n\nfunction GetPrefixLimitForRarity(baseItemId, rarity) {\n  if (rarity === \"normal\") {\n    return 0;\n  }\n  if (rarity === \"magic\") {\n    return 1;\n  }\n  if (rarity === \"rare\" || rarity === \"unique\") {\n    const baseItem = base_items[baseItemId];\n    if (baseItem[\"domain\"] === \"misc\" || baseItem[\"domain\"] === \"abyss_jewel\") {\n      return 2;\n    }\n    return 3;\n  }\n  return 0;\n}\n\nfunction GetSuffixLimitForRarity(baseItemId, rarity) {\n  return GetPrefixLimitForRarity(baseItemId, rarity);\n}\n\nfunction GetAffixLimitForRarity(baseItemId, rarity) {\n  return GetPrefixLimitForRarity(baseItemId, rarity) + GetSuffixLimitForRarity(baseItemId, rarity);\n}\n\nfunction GetPrefixLimit(itemState) {\n  return GetPrefixLimitForRarity(itemState.baseItemId, itemState.rarity);\n}\n\nfunction GetSuffixLimit(itemState) {\n  return GetSuffixLimitForRarity(itemState.baseItemId, itemState.rarity);\n}\n\nfunction GetAffixLimit(itemState) {\n  return GetAffixLimitForRarity(itemState.baseItemId, itemState.rarity); \n}\n\nfunction CanModBeAddedToItem(modId, itemState) {\n  const mod = mods[modId];\n  const baseItem = base_items[itemState.baseItemId];\n  if (mod[\"domain\"] !== baseItem[\"domain\"]) {\n    return false;\n  }\n  if (mod[\"required_level\"] > itemState.level) {\n    return false;\n  }\n  if (mod[\"generation_type\"] === \"prefix\") {\n    if (GetPrefixLimit(itemState) <= GetPrefixCount(itemState)) {\n      return false;\n    }\n  }\n  else if (mod[\"generation_type\"] === \"suffix\") {\n    if (GetSuffixLimit(itemState) <= GetSuffixCount(itemState)) {\n      return false;\n    }\n  }\n  else {\n    return false;\n  }\n  const modGroup = mod[\"group\"];\n  if (modGroup && modGroup !== \"\") {\n    for (const affix of itemState.affixes) {\n      const existingMod = mods[affix.id];\n      if (existingMod[\"group\"] === modGroup) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction GetValidModsForItem(itemState) {\n  const tags = GetItemTags(itemState);\n  let validMods = [];\n  for (const modId in mods) {\n    if (!CanModBeAddedToItem(modId, itemState)) {\n      continue;\n    }\n\n    if (GetSpawnWeightForMod(modId, tags) <= 0) {\n      continue;\n    }\n\n    validMods.push(modId);\n  }\n  return validMods;\n}\n\nfunction CreateWeightedModPool(modIds, tags) {\n  let modPool = {\n    totalWeight : 0,\n    mods : []\n  }\n\n  for (const modId of modIds) {\n    let modWeight = GetSpawnWeightForMod(modId, tags);\n    modPool.mods.push({\n      id : modId,\n      weight : modWeight\n    });\n    modPool.totalWeight += modWeight;\n  }\n\n  return modPool;\n}\n\nfunction PickModFromWeightedModPool(modPool, rng) {\n  const randRoll = randRange(rng, 0, modPool.totalWeight - 1);\n  let weightAccum = 0;\n\n  for (const mod of modPool.mods) {\n    const modEndWeight = weightAccum + mod.weight;\n    if (randRoll < modEndWeight) {\n      return mod.id;\n    }\n    weightAccum = modEndWeight;\n  }\n\n  return null;\n}\n\nfunction GetInfluenceTags(baseItemId, influence) {\n  const baseItem = base_items[baseItemId];\n  const baseItemClass = baseItem[\"item_class\"];\n  if (item_classes.includes(baseItemClass)) {\n    const influenceTagId = influence + \"_tag\";\n    if (item_classes[baseItemClass].includes(influenceTagId)) {\n      const influenceTag = item_classes[baseItemClass][influenceTagId];\n      if (influenceTag) {\n        return [influenceTag];\n      }\n    }\n  }\n  return [];\n}\n\nfunction GetAddedTags(modId) {\n  return mods[modId][\"adds_tags\"];\n}\n\nfunction GetBaseItemTags (itemState) {\n  const baseItem = base_items[itemState.baseItemId];\n  let tags = [];\n  tags = tags.concat(baseItem[\"tags\"]);\n  for (const influence of itemState.influences) {\n    tags = tags.concat(GetInfluenceTags(itemState.baseItemId, influence));\n  }\n  for (const implicit of itemState.implicits) {\n    tags = tags.concat(GetAddedTags(implicit.id));\n  }\n  return tags;\n}\n\nfunction GetItemTags(itemState) {\n  let tags = GetBaseItemTags(itemState);\n  for (const affix of itemState.affixes) {\n    tags = tags.concat(GetAddedTags(affix.id));\n  }\n  return tags;\n}\n\nfunction RollModValues(modId, rng) {\n  let statRolls = [];\n  const mod = mods[modId];\n  for (const stat of mod[\"stats\"]) {\n    statRolls.push(randRange(rng, stat[\"min\"], stat[\"max\"]));\n  }\n  return statRolls;\n}\n\nfunction CreateRolledMod(modId, rng) {\n  return {\n    id : modId,\n    values : RollModValues(modId, rng),\n    tier : 0\n  }  \n}\n\nfunction RollRareAffixCount(baseItemId, rng) {\n  const maxAffixCount = GetAffixLimitForRarity(baseItemId, \"rare\");\n  if (maxAffixCount === 6) {\n    // Number of mods from data mined note (source: POE Discord, #3rd-party-tool-dev)\n    // \"1/12 chance for 6 mods, 4/12 chance for 5 mods, and 7/12 chance for 6 mods\"\n    const randInt = randRange(rng, 0, 11);\n    if (randInt < 7) {\n      return 4;\n    }\n    if (randInt < 11) {\n      return 5;\n    }\n    return 6;\n  }\n  else if (maxAffixCount === 4) {\n    // Number of mods from data mined note (source: reddit, https://www.reddit.com/r/pathofexile/comments/8fxnlu/chance_of_getting_specific_number_of_mods_via/)\n    // \"for jewels: 65/35\"\n    const randInt = randRange(rng, 0, 99);\n    if (randInt < 65) {\n      return 3;\n    }\n    return 4;\n  }\n  else if (maxAffixCount > 0) {\n    // Unexpected situation, roll pure random\n    return randRange(rng, 1, maxAffixCount);\n  }\n  return 0;\n}\n\nfunction CreateItem(baseItemId, level, rng) {\n  let itemState = {\n    generatedName : \"\",\n    baseItemId : baseItemId,\n    level : level,\n    rarity : \"normal\",\n    corrupted : false,\n    quality : 0,\n    influences : [],\n    implicits : [],\n    corruptions : [],\n    affixes : []\n  }  \n\n  // Add and roll implicits\n  const baseItem = base_items[baseItemId];\n  for (const implicitId of baseItem[\"implicits\"]) {\n    itemState.implicits.push(CreateRolledMod(implicitId, rng));\n  }\n\n  return itemState;\n}\n\nfunction AddRandomMod(itemState, rng) {\n  let newItemState = { ...itemState };\n  const validMods = GetValidModsForItem(newItemState);\n  const itemTags = GetItemTags(newItemState);\n  const weightedModPool = CreateWeightedModPool(validMods, itemTags);\n  const modId = PickModFromWeightedModPool(weightedModPool, rng);\n  if (!modId) {\n    return [false, itemState];\n  }\n  newItemState.affixes.push(CreateRolledMod(modId, rng));\n  return [true, newItemState];\n}\n\nfunction CanScourItem(itemState) {\n  if (itemState.rarity === \"normal\") {\n    return false;\n  }\n  if (itemState.rarity === \"unique\") {\n    return false;\n  }\n  if (itemState.corrupted) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ScourItem(itemState, rng) {\n  if (!CanScourItem(itemState)) {\n    return [false, itemState];\n  }\n  return [true, { ...itemState, rarity : \"normal\", affixes : [] }];\n}\n\nfunction CanTransmutationItem(itemState) {\n  if (itemState.rarity !== \"normal\") {\n    return false;\n  }\n  if (itemState.corrupted) {\n    return false;\n  }\n  if (!CanBaseItemHaveRarity(itemState.baseItemId, \"magic\")) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction TransmutationItem(itemState, rng) {\n  if (!CanTransmutationItem(itemState)) {\n    return [false, itemState];\n  }\n\n  let newItemState = { ...itemState, rarity : \"magic\" };\n  const numMods = randRange(rng, 1, 2);\n  for (let i = 0; i < numMods; ++i) {\n    newItemState = AddRandomMod(newItemState, rng)[1];\n  }\n\n  return [true, newItemState];\n}\n\nfunction CanAlterationItem(itemState) {\n  if (itemState.rarity !== \"magic\") {\n    return false;\n  }\n  if (itemState.corrupted) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction AlterationItem(itemState, rng) {\n  if (!CanAlterationItem(itemState)) {\n    return [0, itemState];\n  }\n\n  let newItemState = { ...itemState, affixes : [] };\n  const numMods = randRange(rng, 1, 2);\n  for (let i = 0; i < numMods; ++i) {\n    newItemState = AddRandomMod(newItemState, rng)[1];\n  }\n\n  return [true, newItemState];\n}\n\nfunction CanAugmentationItem(itemState) {\n  if (itemState.rarity != \"magic\") {\n    return false;\n  }\n  if (itemState.corrupted) {\n    return false;\n  }\n  if (GetAffixCount(itemState) >= GetAffixLimit(itemState)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction AugmentationItem(itemState, rng) {\n  if (!CanAugmentationItem(itemState)) {\n    return [false, itemState];\n  }\n\n  const [result, newItemState] = AddRandomMod(itemState, rng);\n  if (!result) {\n    return [false, itemState];\n  }\n  return [true, newItemState];\n}\n\nfunction CanRegalItem(itemState) {\n  if (itemState.rarity != \"magic\") {\n    return false;\n  }\n  if (itemState.corrupted) {\n    return false;\n  }\n  if (!CanBaseItemHaveRarity(itemState.baseItemId, \"rare\")) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction RegalItem(itemState, rng) {\n  if (!CanRegalItem(itemState)) {\n    return [false, itemState];\n  }\n\n  let rareItemState = { ...itemState, rarity : \"rare\" };\n  const [result, newItemState] = AddRandomMod(rareItemState, rng);\n  if (!result) {\n    return [false, itemState];\n  }\n  return [true, newItemState];\n}\n\nfunction CanAlchemyItem(itemState) {\n  if (itemState.rarity !== \"normal\") {\n    return false;\n  }\n  if (itemState.corrupted) {\n    return false;\n  }\n  if (!CanBaseItemHaveRarity(itemState.baseItemId, \"rare\")) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction AlchemyItem(itemState, rng) {\n  if (!CanAlchemyItem(itemState)) {\n    return [false, itemState];\n  }\n\n  let newItemState = { ...itemState, rarity : \"rare\" };\n  const numMods = RollRareAffixCount(itemState.baseItemId, rng);\n  for (let i = 0; i < numMods; ++i) {\n    newItemState = AddRandomMod(newItemState, rng)[1];\n  }\n\n  return [true, newItemState];\n}\n\nfunction CanChaosItem(itemState) {\n  if (itemState.rarity != \"rare\") {\n    return false;\n  }\n  if (itemState.corrupted) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ChaosItem(itemState, rng) {\n  if (!CanChaosItem(itemState)) {\n    return [false, itemState];\n  }\n\n  let newItemState = { ...itemState, affixes : [] };\n  const numMods = RollRareAffixCount(itemState.baseItemId, rng);\n  for (let i = 0; i < numMods; ++i) {\n    newItemState = AddRandomMod(newItemState, rng)[1];\n  }\n\n  return [true, newItemState];\n}\n\nfunction CanExaltedItem(itemState) {\n  if (itemState.rarity != \"rare\") {\n    return false;\n  }\n  if (itemState.corrupted) {\n    return false;\n  }\n  if (GetAffixCount(itemState) >= GetAffixLimit(itemState)) {\n    return false;\n  }\n  \n  return true;\n}\n\nfunction ExaltedItem(itemState, rng) {\n  if (!CanExaltedItem(itemState)) {\n    return [false, itemState];\n  }\n\n  const [result, newItemState] = AddRandomMod(itemState, rng);\n  if (!result) {\n    return [false, itemState];\n  }\n  return [true, newItemState];\n}\n\nfunction CraftingButton(props) {\n  return <button className=\"button\" onClick={props.onClick} disabled={!props.enabled}>{props.label}</button>;\n}\n\nclass TheoryCrafter extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.testMap = {\n      \"scour\" : CanScourItem,\n      \"transmute\" : CanTransmutationItem,\n      \"alt\" : CanAlterationItem,\n      \"aug\" : CanAugmentationItem,\n      \"regal\" : CanRegalItem,\n      \"alch\" : CanAlchemyItem,\n      \"chaos\" : CanChaosItem,\n      \"exalt\" : CanExaltedItem,\n    }\n\n    this.actionMap = {\n      \"scour\" : ScourItem,\n      \"transmute\" : TransmutationItem,\n      \"alt\" : AlterationItem,\n      \"aug\" : AugmentationItem,\n      \"regal\" : RegalItem,\n      \"alch\" : AlchemyItem,\n      \"chaos\" : ChaosItem,\n      \"exalt\" : ExaltedItem,\n    }\n\n    this.rng = seedrandom();\n    const normalItemState = CreateItem(\"Metadata/Items/Armours/Boots/BootsAtlas1\", 100, this.rng);\n    const transmuteResult = TransmutationItem(normalItemState, this.rng);\n    this.state = {\n      itemState : transmuteResult[0] ? transmuteResult[1] : normalItemState\n    }\n  }\n\n  canPerformAction(actionName) {\n    return this.testMap[actionName](this.state.itemState);\n  }\n\n  performAction(actionName) {\n    const result = this.actionMap[actionName](this.state.itemState, this.rng);\n    if (result[0]) {\n      this.setState( {...this.state, itemState : result[1]} );\n    }\n  }\n\n  RenderCraftingButton(actionName, label) {\n    return <CraftingButton onClick={ () => this.performAction(actionName) } enabled={ this.canPerformAction(actionName) } label={label} key={actionName} />\n  }\n\n  render() {\n    return [\n//      <CraftingButton onClick={ () => this.setState(this.state) } enabled=\"true\" label=\"Debug Refresh\" key=\"Refresh\" />,\n      this.RenderCraftingButton(\"scour\", \"Scour\"),\n      this.RenderCraftingButton(\"transmute\", \"Transmutation\"),\n      this.RenderCraftingButton(\"aug\", \"Augmentation\"),\n      this.RenderCraftingButton(\"alt\", \"Alteration\"),\n      this.RenderCraftingButton(\"regal\", \"Regal\"),\n      this.RenderCraftingButton(\"alch\", \"Alchemy\"),\n      this.RenderCraftingButton(\"chaos\", \"Chaos\"),\n      this.RenderCraftingButton(\"exalt\", \"Exalted\"),\n      <CraftedItem itemState={ this.state.itemState } />\n    ]\n  }\n}\n\nfunction App() {\n  return <TheoryCrafter />\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}